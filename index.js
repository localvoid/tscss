#!/usr/bin/env node

"use strict";

const fs = require("fs");
const glob = require("glob");
const crypto = require("crypto");
const path = require("path");
const chalk = require("chalk");
const sane = require("sane");
const keyword = require("esutils").keyword;
const minimist = require("minimist");
const Processor = require("modular-css-core");
const output = require("modular-css-core/lib/output.js");
const packageJSON = require("./package.json");

const args = process.argv.slice(2);
const argv = minimist(args, {
  boolean: [
    "watch",
    "version",
    "help",
  ],
  string: [
    "path",
  ],
  alias: {
    "help": "h",
    "watch": "w",
    "path": "p",
    "version": "v",
  },
  default: {
    "path": "src/**/*.css",
  },
});

if (argv["version"]) {
  process.stdout.write(packageJSON.version);
  process.exit(0);
}

if (argv["help"]) {
  process.stdout.write(
    `Usage: tscss [opts]\n\n` +
    `Available options:\n` +
    `  --path or -p <path>   Minimatch pattern for css files. Defaults to "src/**/*.css".\n` +
    `  --watch or -w         Enable watch mode.\n` +
    `  --version or -v       Print tscss version.\n` +
    `\n`
  );
  process.exit(0);
}

const processor = new Processor();

const HEADER = `
/**
 * DO NOT MODIFY!
 * 
 * Automatically generated by tscss.
 */
`.trim();

const globPath = argv["path"];

function resolveFilePath(filePath) {
  return filePath + ".d.ts";
}

function relativeFilePath(filePath) {
  return path.relative(process.cwd(), filePath);
}

class TaskQueue {
  constructor() {
    this.tasks = [];
    this.onFinish = null;
    this._next = this._next.bind(this);
  }

  push(task) {
    if (this.tasks.length === 0) {
      task().then(this._next);
    } else {
      this.tasks.push(task);
    }
  }

  _next() {
    if (this.tasks.length > 0) {
      const task = this.tasks.unshift();
      task().then(this._next);
    } else {
      if (this.onFinish !== null) {
        this.onFinish();
      }
    }
  }
}

function generateFile(result) {
  const classes = output.join(result.exports);
  const named = Object.keys(classes);

  let content = HEADER + "\n\n";

  named.forEach((ident) => {
    if (keyword.isReservedWordES6(ident) || !keyword.isIdentifierNameES6(ident)) {
      process.stderr.write(
        chalk.red(`${relativeFilePath(filePath)}: Invalid JS identifier "${ident}", unable to generate`)
      );
    }
    content += `export const ${ident}: string;\n`;
  });

  const filePath = resolveFilePath(result.file);
  const prevContent = fs.readFileSync(filePath);
  if (
    crypto.createHash("sha1").update(content).digest("base64") !==
    crypto.createHash("sha1").update(prevContent).digest("base64")
  ) {
    fs.writeFileSync(filePath, content);
    process.stdout.write(chalk.green(`  ${relativeFilePath(filePath)} generated\n`));
  }
}

function generate(queue, p) {
  const files = glob.sync(p);
  for (const file of files) {
    queue.push(function () {
      return processor.file(file).then(generateFile);
    });
  }
}

const queue = new TaskQueue();

if (argv["watch"]) {
  const watcher = sane(process.cwd(), { glob: [globPath] });

  function watch() {

    watcher.on("ready", function () {
      generate(queue, globPath);
      process.stdout.write(chalk.underline(`Started watching: ${globPath}\n\n`));
    });

    watcher.on("change", function (filePath, root, stat) {
      process.stdout.write(chalk.yellow(`  ${relativeFilePath(filePath)} changed\n`));
      processor.remove(filePath);
      queue.push(function () {
        return processor.file(filePath).then(generateFile);
      });
    });

    watcher.on("add", function (filePath, root, stat) {
      process.stdout.write(chalk.yellow(`  ${relativeFilePath(filePath)} added\n`));
      queue.push(function () {
        return processor.file(filePath).then(generateFile);
      });
    });

    watcher.on("delete", function (filePath, root) {
      process.stdout.write(chalk.yellow(`  ${relativeFilePath(filePath)} removed\n`));
      processor.remove(filePath);
      fs.unlinkSync(resolveFilePath(filePath));
    });

    process.on("SIGINT", function () {
      watcher.close();
      process.exit();
    });
  }

  watch();
} else {
  queue.onFinish = function () {
    process.exit(0);
  };
  generate(queue, globPath);
}
